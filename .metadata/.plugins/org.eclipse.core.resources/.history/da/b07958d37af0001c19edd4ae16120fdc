package fr.diginamic.java17.gestiondepersonnes;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import fr.diginamic.java17.gestiondepersonnes.classes.Facteur;
import fr.diginamic.java17.gestiondepersonnes.classes.Personne;
import fr.diginamic.java17.gestiondepersonnes.enums.Genre;

public class AppStream01Collect {

	public static void main(String[] args) {

		List<Personne> lp = new ArrayList();
		lp.add(new Facteur("Fact01", "Jean", Genre.Mr));
		lp.add(new Facteur("Fact02", "martine", Genre.Mme));
		lp.add(new Facteur("Fact03", "pauline", Genre.Melle));
		lp.add(new Facteur("Fact04", "paul", Genre.Mr));

		/**
		 * 1 récupérer la liste des noms de facteurs 2 récupérer les noms des facteurs
		 * dans une chaine (sans séparateur explicite) 3 récupérer les noms des facteurs
		 * dans une chaine (avec ;)
		 */

//1

		/**
		 * List<String> lnoms c'est le résultat attendu -> IMPOSER EN STREAM ? :
		 * lp.stream() noms des Facteurs : map(p->p.getNom()) -> mettre en mémoire de ma
		 * liste : List<Personne> => uniquement le nom du Facteur Collect : Traitement
		 * qui me retourne un flux d'information correspondant au type attendu en
		 * résultat List<String> collect(Collectors.toList()) Collectors.toList() :
		 * c'est le type de List du contenu dépendant du map. C'est pour cela que
		 * j'obtiens une liste de String
		 */
		List<String> lnoms = lp.stream().map(p -> p.getNom()).collect(Collectors.toList());

//AVANT
		List<String> lnomsV0 = new ArrayList<String>();
		for (Personne p : lp) {
			lnomsV0.add(p.getNom());
		}

		/**
		 * forEach(System.out::println) Je dépend du type de Lambda Expression de la
		 * méthode () -> forEach(s-> avec la variable)
		 *
		 * forEach(System.out::println) lnoms est une List<String> donc s est un string
		 * forEach(s -> System.out.println(s)) On appelle de façon "statique" la méthode
		 * println de System.out System.out::println : c'est une synthase "alias" Java
		 * fait un callback = il traduit en Lambda Expression selon la définition de la
		 * méthode de la classe avec le ou les paramétres attendues par cette méthode et
		 * aussi de l'appelant : forEach
		 *
		 */
		lnoms.forEach(System.out::println);
		
		/**
		* 2 Récuperer les noms des Facteurs dans une chaîne (sans séparateur explicite)
		*/
		
		String nomsDesPersonnes = lp.stream().map(p->p.getNom()).
				collect(Collectors.joining());
				//Une concaténation les noms dans un String
		
		
	}

}
